package kecpsignal

import (
	"bytes"
	"io"
	"time"

	kecpmsg "github.com/fourdim/kecp/modules/kecp-msg"
	kecpvalidate "github.com/fourdim/kecp/modules/kecp-validate"
	"github.com/gorilla/websocket"
)

const (
	// Time allowed to write a message to the peer.
	writeWait = 10 * time.Second

	// Time allowed to read the next pong message from the peer.
	pongWait = 60 * time.Second

	// Send pings to peer with this period. Must be less than pongWait.
	pingPeriod = (pongWait * 9) / 10

	// Maximum message size allowed from peer.
	maxMessageSize = 512

	// Time allowed to get an ack from a room.
	clientJoinedCheckWait = 2 * time.Second
)

var (
	newline = []byte{'\n'}
	space   = []byte{' '}
)

type Client struct {

	// The clientKey is generated by the client.
	// Should be readonly.
	clientKey string

	// The name is provided by the client.
	// Should be unique in one room, and will be known to other clients.
	// Should be readonly.
	name string

	// The room it belongs.
	room *Room

	// The websocket connection.
	conn WebscoketConn

	// Buffered channel of outbound messages.
	send chan *kecpmsg.Message

	// The status returned after register.
	joined chan bool

	// Channel for self destruction.
	selfDestruction chan bool
}

type WebscoketConn interface {
	Close() error
	NextWriter(messageType int) (io.WriteCloser, error)
	SetPongHandler(h func(appData string) error)
	ReadMessage() (messageType int, p []byte, err error)
	SetReadDeadline(t time.Time) error
	SetReadLimit(limit int64)
	SetWriteDeadline(t time.Time) error
	WriteMessage(messageType int, data []byte) error
}

func (room *Room) NewClient(name string, key string, conn WebscoketConn) error {
	if !kecpvalidate.IsAValidUserName(name) {
		conn.Close()
		return ErrNotAValidName
	}
	if room == nil {
		conn.Close()
		return ErrCanNotJoinTheRoom
	}
	client := &Client{
		clientKey:       key,
		name:            name,
		room:            room,
		conn:            conn,
		send:            make(chan *kecpmsg.Message, 256),
		joined:          make(chan bool),
		selfDestruction: make(chan bool),
	}
	room.register.Write(client)
	checker := time.NewTimer(clientJoinedCheckWait)
	defer checker.Stop()
	select {
	case joined := <-client.joined:
		if !joined {
			client.conn.Close()
			return ErrNameIsAlreadyInUse
		}
	case <-checker.C:
		client.conn.Close()
		return ErrCanNotJoinTheRoom
	}
	go client.readPump()
	go client.writePump()
	return nil
}

// readPump pumps messages from the websocket connection to the room.
//
// The application runs readPump in a per-connection goroutine. The application
// ensures that there is at most one reader on a connection by executing all
// reads from this goroutine.
//
// server <- client
func (c *Client) readPump() {
	defer func() {
		c.room.unregister.Write(c)
		c.conn.Close()
	}()
	c.conn.SetReadLimit(maxMessageSize)
	c.conn.SetReadDeadline(time.Now().Add(pongWait))
	c.conn.SetPongHandler(func(string) error { c.conn.SetReadDeadline(time.Now().Add(pongWait)); return nil })
	for {
		_, msg, err := c.conn.ReadMessage()
		if err != nil {
			if websocket.IsUnexpectedCloseError(err, websocket.CloseGoingAway, websocket.CloseAbnormalClosure) {
				logger.Printf("error: %v", err)
			}
			break
		}
		msg = bytes.TrimSpace(bytes.Replace(msg, newline, space, -1))
		kecpMsg, err := kecpmsg.Parse(msg, c.name)
		if err != nil {
			continue
		}

		if kecpMsg.NeedBroadcast() {
			c.room.broadcast.Write(kecpMsg)
		} else {
			c.room.forward.Write(kecpMsg)
		}
	}
}

// writePump pumps messages from the room to the websocket connection.
//
// A goroutine running writePump is started for each connection. The
// application ensures that there is at most one writer to a connection by
// executing all writes from this goroutine.
//
// server -> client
func (c *Client) writePump() {
	ticker := time.NewTicker(pingPeriod)
	defer func() {
		ticker.Stop()
		c.conn.Close()
	}()
	for {
		select {
		case kecpMsg, ok := <-c.send:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if !ok {
				// The room closed the channel.
				c.conn.WriteMessage(websocket.CloseMessage, []byte{})
				return
			}

			w, err := c.conn.NextWriter(websocket.TextMessage)
			if err != nil {
				return
			}
			w.Write(kecpMsg.Build())

			// Add queued chat messages to the current websocket message.
			n := len(c.send)
			for i := 0; i < n; i++ {
				w.Write(newline)
				kecpMsg := <-c.send
				w.Write(kecpMsg.Build())
			}

			if err := w.Close(); err != nil {
				return
			}
		case <-ticker.C:
			c.conn.SetWriteDeadline(time.Now().Add(writeWait))
			if err := c.conn.WriteMessage(websocket.PingMessage, nil); err != nil {
				return
			}
		case <-c.selfDestruction:
			return
		}
	}
}
